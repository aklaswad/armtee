TOCBEGIN
[[toc]]
TOCEND

# Why armtee?

This project has started for my another project, from modifying [Resig's Micro Templating](https://johnresig.com/blog/javascript-micro-templating/) for generic text template.

As of writhing this, there are still no armtee users, so here I'll descibe the reason _why I made armtee_, instead of promotional taglines.

## Development history

私は、これとは別のソフトの開発のために、テンプレートエンジンを探していましたが、小さくて拡張性が高く、ウェブ専用の余計な機能がついていないものです。
強いて言えば Go のtext templateが理想に近いものでしたが、そのためだけに開発言語を Go に変更するのは厳しい状況でした。

正直言って単に自分のエンジンが欲しかっただけかも知れません。

懐かしいResig Micro Templatingを出発点に、HTMLに依存した部分を取り除くことからはじめました。
次に、ファイルのインクルードのために新しい構文を組み込みました。
RMTはJSをその場で生成する仕組みのため、おかしなところにファイルをインクルードするとJS自体が破壊されます。
どこにインクルードが行われるかをわかりやすくするよう、マクロ行のかたちにして事前処理することにしました。

私がそのときトライしていたのはBashスクリプトを生成するテンプレートだったので、`#`から始まる行にマクロを組み込めばシンタックスハイライトの邪魔にもならず都合が良かったのでそうしました。
すぐに、これは他のループ処理などの複雑な部分をテンプレートから分離することにも応用できることに気づきました。

このアイデアはなかなか気に入っています。でも、この頃までは、別のソフトの１モジュールのままにしておくべきだっと考えていました。
いまさらテンプレートエンジンを公開しても仕方ないと思っていたし、なにより決り文句「こいつはエスケープなんて丁寧なことはしてくれないから、なにがユーザー入力かもわからない状態でウェブコンテンツに出力させるな」といったやつを自分の口から言うのが嫌だったのもあります。

開発が進み、テンプレートが複雑になるに従ってデバッグが難しくなってきたので、もう少ししっかりとテンプレートと成果物のエラー行の対応を追跡できるように手を入れ始めました。まるでsource mapですね。
そうか、こいつはトランスコンパイラでもあるんだなあ、と考えを広げていって、思った以上に応用できる範囲が広そうな事に気づきました。

## Features

### Line oriented markup

テンプレートロジックとテンプレート出力の記述を、同一ファイル内で取り扱いつつ、明確に分離させることで可読性とメンテナンス性を向上させます。

### Syntax Highlight Friendly

複数のシンタックスモードを切り替えることで既存のsyntax highlightや入力補完を簡単に利用できます。

### Template only knows what is TAG

テンプレート内に埋め込むタグの形式をテンプレート側から自由に変更できます。これも従来のテンプレートエンジンにはなかった特徴かもしれません。
タグの形式(`<% ... %>` なのか `{{ ... }}`なのか、のような)は、テンプレートが何を記述すべきかにあわせて選択されるべきで、それはテンプレートが知っていれば良いことです。

### トランスパイラであることを活かした独立ビルド

armteeを使って直接テンプレートの出力を得るだけでなく、トランスパイルされたレンダラーをJSモジュールとして再利用したり、JSONあるいはCSVVのフォーマッタとしてシェルから利用するスクリプトにしたり出来る予定です。

# Template Syntax

具体的にテンプレートの記述を見ていきましょう。
armteeのテンプレートは、後述するようにファイルモードやタグの記法を自由に選ぶ柔軟性がありますが、この文章内では説明がない場合は**hashy-template**モードで、タグはデフォルトのタグ記法 `<%`と`%>` で説明します。

## 行リテラルとTAG

armteeのテンプレートは、行(または複数行のブロック)単位で何を行うかが明確に別れています。
以下の４種類があります。

 - template
 - script
 - macro
 - comment

各行を`##! `のような、空白を含めた __4文字__ ではじめることでarmteeにそれぞれの行が何かを伝えます。
この４文字を __行修飾子__ とでも呼びましょう。

後述するファイルのモードによって、それ以外の行はtemplate行かscript行であるとみなされます。


一般的ないわゆるテンプレートタグは、template行でのみ有効です。

## ファイルのモード

armteeのテンプレートではいくつかのバリエーションを持つシンタックスを使い分けることができます。

行リテラルには、`##! `のように２つのハッシュ`#`で始まる **hashy** スタイルと、`//! `のように２つのスラッシュで始まる **slashy** スタイルがあります。
（この意図はいくつかのプログラム言語に触れたことがあるユーザーには理解できると思います）

それに加えて、JavaScriptのロジック行をを`##! `行で記述し、シンボルなしの行をテンプレート行とみなすテンプレートモードと、シンボルなしの行をscriptとみなし、テンプレート行を`##> `行修飾子で記述するロジックモードを使い分けることができます。

つまり、以下の４種類の記法が利用できます。これらは表面的なマークアップが異なるだけで、行われる処理に違いはありません。

**hashy-template**

```
##! data.items.forEach( item => {     // この行はscript行
##-     コメント行
テンプレートからアイテム「<% item.toString() %>」を出力
##! })
```

**hashy-logic**
```
data.items.forEach( item => {     // この行はscript行
##-     コメント行
##> テンプレートからアイテム「<% item.toString() %>」を出力
})
```

**slashy-template**
```
//! data.items.forEach( item => {     // この行はscript行
//-     コメント行
テンプレートからアイテム「<% item.toString() %>」を出力
//! })
```

**slashy-logic**
```
data.items.forEach( item => {     // この行はscript行
//-     コメント行
//> テンプレートからアイテム「<% item.toString() %>」を出力
})
//> 
```

これらの４つの記法は相互変換可能であり、記述したいテンプレートの内容や、テンプレートにフォーカスして作業しているか、あるいはロジックを(シンタックスハイライトを有効にして)作成しているかなど、状況に合わせて使い分けることができます。

armteeはこれらのモードを自動的に判別します。(テンプレート行リテラルもscript行リテラルも存在しないなど）判別できない場合はテンプレートモードとみなされます。

これらの記法は１ファイルの中で混在させることはできません。
具体的には1ファイル中にhashyリテラルとslashyリテラルが同時に存在した場合、またはテンプレート行リテラルとscript行リテラルが同時に存在した場合には読み込みエラーとなります。

### template行

出力される内容を決定するテンプレートです。
テンプレートタグを埋め込んでJavaScriptの式を展開できます。

テンプレートモードでは、他の行リテラルではないすべての行がテンプレート行になります。
ロジックモードでは、`##> ` （または`//> `)ではじまる行がテンプレート行になります。

RMTで存在した`<% 文または文やブロックのの断片 %>`のような使い方はできません。すべてのタグ内部は評価可能なJavaScriptの式である必要があります。

タグは改行をまたぐことはできません。ある行で始まったタグは、その行で終了する必要があります。
タグの中にメソッドチェーンを埋め込んでいたら一行に収まらなくなった。そんなときは、事前にスクリプトブロックで処理を行うことを検討してください。

### script行

主にテンプレートのロジカルな処理を行うためのJavaScriptを記述します。改変されることなくトランスパイル後のファイルに出力されます。

テンプレートモードでは `##! ` または（`//! `）ではじまる行がscript行になります。
ロジックモードでは、他の行リテラルではないすべての行がscript行になります。

script行にのみある制約として、JavaScriptとしてまとまった分割できない処理は間に別の種類の行や空行などを挟むことはできません。
armteeがデバッグ情報を埋め込むことが可能だと判断するためです。

```javascript
##! data.longNamedArrayMember
##!   .map( item => item.foo ? item.bar : item.buz )
##- comment: I found a bug so I'll add one more filter...
##!   .filter( item => item.mustBeTruthy )
```

### macro行

armteeに各種の指定を行ったりします。

`##% `または `//% `ではじまる行がmacro行になります。

### comment行

コメント行です。単に無視されます。

`##- `または  `//- `で始まる行がコメント行になります。
`
以前は`### `という記法でした。コメントのダメ押し感が好きだったのですが、まさに今ドキュメントをマークダウンで書いていて、バッティングすることに気づきやめました。
マイナスだから取り去るんだろうと思ってください。

# Macro

マクロ行では、事前に用意されたいくつかのマクロを呼び出すことができます。コマンド名と、コマンドによってはいくつかの引数を空白区切りで渡す必要があります。

## ROOT

テンプレートの中でルートオブジェクトを受け取る際の変数名を指定できます。デフォルトでは`data`として渡されますが、そのテンプレートが何を扱うかを明確化するためなどいくつかの目的で変更を行えます。

```
My name is <% data.name %>
```

これはトランスパイルの出力としては以下のようになります。（実際の出力とは異なります。)

```javascript
((data,_$) => {
  _$`My name is ${ data.name }`
})(data,printer)
```

これは、次のようにROOTを利用することで意図が明確になります。
```
##% ROOT user
My name is <% user.name %>
```

これはトランスパイルの出力としては以下のようになります。（実際の出力とは異なります。)

```javascript
((user,_$) => {
  _$`My name is ${ user.name }`
})(data,printer)
```

## TAG

テンプレートの中で、以降の行でタグとして認識される記号のペアを設定できます。

```
##% TAG START_TAG END_TAG
```

以下のように、複数のタグ記法を同一テンプレート内で使い分けることもできます。
```
##% TAG {{ }}
My name is {{ data.name }}
##- Use another tag
##% TAG <! !>
I came from <! data.country !>
```

デフォルトは`<%` `%>`です。

## INCLUDE

```
##% INCLUDE filepath <ROOT_ITEM>
```

他のテンプレートをインクルードします。インクルードはトランスパイル前に静的に処理されます。トランスパイル時、あるいはレンダリングの実行時に読み込むテンプレートを変更するようなことはできません。

読み込むテンプレートのパスは、現在のテンプレートからの相対パスになります。shellの$PATHのようなサーチパスやフォールバック機構はありません。

ROOT_ITEMを指定することで、現在のテンプレート内で有効なデータの一部だけを、読み込むテンプレートのロート処理対象として渡すことができます。省略した場合、呼び出し元テンプレートのルートデータが渡されます **TODO要検討**

```
##! data.friends.forEach( friend => {
##%   INCLUDE deathnote.tmpl friend
##! })
```

nodejs環境でのみ利用可能です。


## Filter

# API

### Armtee.render

```javascript
import Armtee from 'armtee'
const rendered = Armtee.render(templateText, data)
```

# cli




